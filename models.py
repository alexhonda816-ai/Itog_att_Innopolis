import re

class BaseModel:
    def to_dict(self):
        """Преобразует атрибуты объекта в словарь."""
        """Это простой базовый класс, обеспечивающий удобный способ преобразовывать экземпляры классов в представление 
        словаря. Метод to_dict() возвращает содержимое объекта в виде словаря благодаря встроенному методу vars(), 
        который извлекает атрибуты объекта."""
        return vars(self)

class Client(BaseModel):
    def __init__(self, name, email, phone, address, id=None):
        self.id = id
        self.name = name
        self._email = email  # Использование приватного атрибута для хранения почты
        self.phone = phone
        self.address = address

    """Свойство (@property)— это специальный механизм Python, позволяющий создавать контролируемые интерфейсы доступа 
    к атрибутам объекта. Вместо простого обращения к полям, свойства позволяют добавлять дополнительную логику 
    при чтении и записи значений. Обычно это делается для дополнительной проверки данных, вычисления динамических 
    значений или ограничения изменений
    
    Поле _email обозначено символом подчеркивания в начале имени. Это соглашение показывает другим программистам, 
    что это внутреннее поле, и прямое обращение к нему нежелательно. Доступ рекомендуется осуществлять 
    через методы-геттеры и сеттеры.
    
    Этот метод определяет чтение атрибута email. Когда мы обращаемся к значению атрибута obj.email, 
    Python вызывает именно этот метод, возвращающий нам защищённое значение."""
    @property
    def email(self):
        """Получает значение email."""
        return self._email

    """Этот метод управляет процессом присвоения нового значения атрибуту email. 
    Здесь реализуется важная логика валидации: регулярное выражение проверяет, соответствует ли заданный адрес 
    электронной почты требуемым стандартам. Если адрес некорректен, поднимается ошибка (ValueError); 
    иначе новое значение присваивается внутренней переменной _email."""
    @email.setter
    def email(self, value):
        """Устанавливает email с предварительной валидацией формата адреса электронной почты."""
        if not re.match(r"[^\s@]+@[^\s@]+\.[^\s@]+", value):
            raise ValueError("Некорректный формат email")
        self._email = value
    """
    Зачем это нужно?
    Использование свойств позволяет контролировать процесс установки и получения значений:

    Безопасность: Мы можем ограничить доступ к важным полям, предотвращая случайные неправильные модификации.
    Валидация: Мы можем проверять данные перед изменением, исключая ситуации, когда пользователи устанавливают недопустимые значения.
    Расширяемость: Свойства облегчают дальнейшее развитие кода, поскольку теперь мы можем включить любую необходимую обработку внутри методов.
    """

    def validate(self):
        """"Проверяет правильность заполнения полей (почта и телефон)."""
        errors = []
        if not re.match(r"[^\s@]+@[^\s@]+\.[^\s@]+", self.email):
            errors.append(f"Некорректный формат email: {self.email}")
        if not re.match(r"^\+?\d+$", self.phone):
            errors.append(f"Некорректный формат телефона: {self.phone}")
        if errors:
            raise ValueError("\n".join(errors))
        return True

    """
    Регулярное выражение re.match(r"[^\s@]+@[^\s@]+\.[^\s@]+", value) обеспечивает следующую проверку:
    [^\s@]+: любое количество символов кроме пробелов и символа "@".
    @: обязательное наличие знака "@".
    [^\s@]+: аналогично первой части, но после "@".
    \.: обязательная точка после домена.
    [^\s@]+: любые символы после точки, формирующие расширение домена.
    Такое регулярное выражение гарантирует, что почтовые адреса имеют вид хотя бы минимально похожий на реальные ("example@example.com").
    """

class Product(BaseModel):
    def __init__(self, name, price, id=None):
        self.id = id
        self.name = name
        self.price = price


class Order(BaseModel):
    def __init__(self, id, client_id, products, order_date, _total_cost=None, client_name="", items=""):
        self.id = id
        self.client_id = client_id
        self.products = products
        self.order_date = order_date
        self._total_cost = _total_cost  # Скрытое поле для итоговой стоимости
        self.client_name = client_name  # Имя клиента
        self.items = items              # Форматированный список товаров

    @property
    def total_cost(self):
        return self._total_cost
